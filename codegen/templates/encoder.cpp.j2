// *** AUTOGENERATED â€“ DO NOT EDIT (run: python codegen/generate.py) ***

 #include "encoder.hpp"

{% set ns_parts = protocol.split('_') %}
{% if ns_parts|length > 1 %}

namespace {{ ns_parts[0] }} { namespace {{ ns_parts[1] }} { namespace v{{ version }} {
{% else %}

namespace {{ protocol }} { namespace v{{ version }} {
{% endif %}

{% for msg in model.messages %}
market::runtime::status Encoder::encode(const {{ msg.name }}& m, uint8_t* out, size_t out_sz, size_t& written) {
    using market::runtime::status;
    using market::runtime::store_le;
    using market::runtime::store_be;

    // Compute required size
    size_t required = 0;
    {# Base fields #}
    {% for f in msg.fields %}
    {% if f.optional_bit is not none %}
    if ((m.{{ msg.presence_field }} & (1ULL << {{ f.optional_bit }})) != 0) required += {{ f.size }};
    {% else %}
    required += {{ f.size }};
    {% endif %}
    {% endfor %}
    {# Groups #}
    {% for g in msg.groups %}
    for (size_t __i = 0; __i < m.{{ g.vector_name }}.size(); ++__i) {
        {% for gf in g.fields %}
        {% if gf.optional_bit is not none %}
        if ((m.{{ msg.presence_field }} & (1ULL << {{ gf.optional_bit }})) != 0) required += {{ gf.size }};
        {% else %}
        required += {{ gf.size }};
        {% endif %}
        {% endfor %}
    }
    {% endfor %}

    if (out_sz < required) { written = 0; return status::short_buffer; }

    size_t offset = 0;

    // Encode fields
    {% for f in msg.fields %}
    {% set is_count = (f.name in msg.count_field_map) %}
    {% set vecname = msg.count_field_map.get(f.name) if is_count else '' %}
    {% if is_count %}
    {# group count field: encode from vector size #}
    {% set gvec = vecname %}
    {% if f.size == 1 %}
    out[offset] = static_cast<uint8_t>(m.{{ gvec }}.size());
    offset += 1;
    {% elif f.endian == 'le' %}
    store_le<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(out + offset, static_cast<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(m.{{ gvec }}.size()));
    offset += {{ f.size }};
    {% else %}
    store_be<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(out + offset, static_cast<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(m.{{ gvec }}.size()));
    offset += {{ f.size }};
    {% endif %}
    {% elif f.has_value and f.type == 'char' and f.size == 1 %}
    out[offset] = static_cast<uint8_t>({{ "'{}'".format(f.value) if f.value is string else f.value }});
    offset += 1;
    {% elif f.has_value and f.type in ['u8','u16','u32','u64'] %}
    {% if f.size == 1 %}
    out[offset] = static_cast<uint8_t>({{ f.value }});
    offset += 1;
    {% elif f.endian == 'le' %}
    store_le<{{ 'uint8_t' if f.size==1 else ('uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t')) }}>(out + offset, static_cast<{{ 'uint8_t' if f.size==1 else ('uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t')) }}>({{ f.value }}));
    offset += {{ f.size }};
    {% else %}
    store_be<{{ 'uint8_t' if f.size==1 else ('uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t')) }}>(out + offset, static_cast<{{ 'uint8_t' if f.size==1 else ('uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t')) }}>({{ f.value }}));
    offset += {{ f.size }};
    {% endif %}
    {% elif f.name == msg.length_field %}
    {% if f.size == 1 %}
    out[offset] = static_cast<uint8_t>(required);
    offset += 1;
    {% elif f.endian == 'le' %}
    store_le<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(out + offset, static_cast<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(required));
    offset += {{ f.size }};
    {% else %}
    store_be<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(out + offset, static_cast<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(required));
    offset += {{ f.size }};
    {% endif %}
    {% else %}
    {% if f.optional_bit is not none %}
    if ((m.{{ msg.presence_field }} & (1ULL << {{ f.optional_bit }})) != 0) {
    {% endif %}
        {# actual field data #}
        {% if f.type == 'char' and f.size > 1 %}
        std::memcpy(out + offset, m.{{ f.name }}.data(), {{ f.size }});
        offset += {{ f.size }};
        {% elif f.type == 'char' and f.size == 1 %}
        out[offset] = static_cast<uint8_t>(m.{{ f.name }});
        offset += 1;
        {% elif f.type in ['u8','u16','u32','u64'] %}
        {% if f.size == 1 %}
        out[offset] = static_cast<uint8_t>(m.{{ f.name }});
        offset += 1;
        {% elif f.endian == 'le' %}
        store_le<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(out + offset, m.{{ f.name }});
        offset += {{ f.size }};
        {% else %}
        store_be<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(out + offset, m.{{ f.name }});
        offset += {{ f.size }};
        {% endif %}
        {% elif f.type == 'enum' %}
        {% set underlying = model.enums_map[f.enum_type].underlying %}
        {% if model.enums_map[f.enum_type].width_bytes == 1 %}
        out[offset] = static_cast<uint8_t>(m.{{ f.name }});
        offset += 1;
        {% elif f.endian == 'le' %}
        store_le<{{ underlying }}>(out + offset, static_cast<{{ underlying }}>(m.{{ f.name }}));
        offset += {{ model.enums_map[f.enum_type].width_bytes }};
        {% else %}
        store_be<{{ underlying }}>(out + offset, static_cast<{{ underlying }}>(m.{{ f.name }}));
        offset += {{ model.enums_map[f.enum_type].width_bytes }};
        {% endif %}
        {% else %}
        // Fallback: memcpy bytes for unknown type size
        std::memcpy(out + offset, &m.{{ f.name }}, {{ f.size }});
        offset += {{ f.size }};
        {% endif %}
    {% if f.optional_bit is not none %}
    }
    {% endif %}
    {% endif %}
    {% endfor %}

    // Encode groups
    {% for g in msg.groups %}
    for (size_t __i = 0; __i < m.{{ g.vector_name }}.size(); ++__i) {
        {% for gf in g.fields %}
        {% if gf.optional_bit is not none %}
        if ((m.{{ msg.presence_field }} & (1ULL << {{ gf.optional_bit }})) != 0) {
            {% endif %}
            {% if gf.type == 'char' and gf.size > 1 %}
            std::memcpy(out + offset, m.{{ g.vector_name }}[__i].{{ gf.name }}.data(), {{ gf.size }});
            offset += {{ gf.size }};
            {% elif gf.type == 'char' and gf.size == 1 %}
            out[offset] = static_cast<uint8_t>(m.{{ g.vector_name }}[__i].{{ gf.name }});
            offset += 1;
            {% elif gf.type in ['u8','u16','u32','u64'] %}
            {% if gf.size == 1 %}
            out[offset] = static_cast<uint8_t>(m.{{ g.vector_name }}[__i].{{ gf.name }});
            offset += 1;
            {% elif gf.endian == 'le' %}
            store_le<{{ 'uint16_t' if gf.size==2 else ('uint32_t' if gf.size==4 else 'uint64_t') }}>(out + offset, m.{{ g.vector_name }}[__i].{{ gf.name }});
            offset += {{ gf.size }};
            {% else %}
            store_be<{{ 'uint16_t' if gf.size==2 else ('uint32_t' if gf.size==4 else 'uint64_t') }}>(out + offset, m.{{ g.vector_name }}[__i].{{ gf.name }});
            offset += {{ gf.size }};
            {% endif %}
            {% elif gf.type == 'enum' %}
            {% set underlying = model.enums_map[gf.enum_type].underlying %}
            {% if model.enums_map[gf.enum_type].width_bytes == 1 %}
            out[offset] = static_cast<uint8_t>(m.{{ g.vector_name }}[__i].{{ gf.name }});
            offset += 1;
            {% elif gf.endian == 'le' %}
            store_le<{{ underlying }}>(out + offset, static_cast<{{ underlying }}>(m.{{ g.vector_name }}[__i].{{ gf.name }}));
            offset += {{ model.enums_map[gf.enum_type].width_bytes }};
            {% else %}
            store_be<{{ underlying }}>(out + offset, static_cast<{{ underlying }}>(m.{{ g.vector_name }}[__i].{{ gf.name }}));
            offset += {{ model.enums_map[gf.enum_type].width_bytes }};
            {% endif %}
            {% else %}
            std::memcpy(out + offset, &m.{{ g.vector_name }}[__i].{{ gf.name }}, {{ gf.size }});
            offset += {{ gf.size }};
            {% endif %}
        {% if gf.optional_bit is not none %}
        }
        {% endif %}
        {% endfor %}
    }
    {% endfor %}

    written = required;
    return status::ok;
}

{% endfor %}

{% if ns_parts|length > 1 %}
}  // namespace v{{ version }}
}  // namespace {{ ns_parts[1] }}
}  // namespace {{ ns_parts[0] }}
{% else %}
}  // namespace v{{ version }}
}  // namespace {{ protocol }}
{% endif %}
