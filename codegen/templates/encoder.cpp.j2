// *** AUTOGENERATED â€“ DO NOT EDIT (run: python codegen/generate.py) ***

#include "encoder.hpp"

{%- set ns_parts = protocol.split('_') %}
{%- if ns_parts|length > 1 %}

namespace {{ ns_parts[0] }} { namespace {{ ns_parts[1] }} { namespace v{{ version }} {
{%- else %}

namespace {{ protocol }} { namespace v{{ version }} {
{%- endif %}

{%- if schema.get('messages', {}).get('LoginRequest') %}

market::runtime::status Encoder::encode(const LoginRequest& m, uint8_t* out, size_t out_sz, size_t& written) {
    constexpr size_t TOTAL_SIZE = 2 + 2 + 1 + 4 + 20; // StartOfMessage + MessageLength + MessageType + Username + Password
    
    if (out_sz < TOTAL_SIZE) {
        written = 0;
        return market::runtime::status::short_buffer;
    }
    
    size_t offset = 0;
    
    // StartOfMessage (u16 LE, fixed value 0xBABA)
    market::runtime::store_le<uint16_t>(out + offset, 0xBABA);
    offset += 2;
    
    // MessageLength (u16 LE, total message size)
    market::runtime::store_le<uint16_t>(out + offset, static_cast<uint16_t>(TOTAL_SIZE));
    offset += 2;
    
    // MessageType (u8, LoginRequest enum value)
    out[offset] = static_cast<uint8_t>(MessageType::LoginRequest);
    offset += 1;
    
    // Username (char[4])
    std::memcpy(out + offset, m.Username.data(), 4);
    offset += 4;
    
    // Password (char[20])
    std::memcpy(out + offset, m.Password.data(), 20);
    offset += 20;
    
    written = TOTAL_SIZE;
    return market::runtime::status::ok;
}

{%- endif %}

{%- if schema.get('messages', {}).get('NewOrderCross') %}

market::runtime::status Encoder::encode(const NewOrderCross& m, uint8_t* out, size_t out_sz, size_t& written) {
    // Calculate group bytes based on presence bit 9
    bool include_account = (m.PresenceBits & (1ULL << 9)) != 0;
    size_t group_item_size = 1 + 4 + 20; // Side + AllocQty + ClOrdId
    if (include_account) {
        group_item_size += 16; // Account
    }
    size_t group_bytes = m.groups.size() * group_item_size;
    
    // Total message size: StartOfMessage(2) + MessageLength(2) + MessageType(1) + PresenceBits(8) + CrossId(20) + GroupCount(1) + group_bytes
    size_t total_size = 2 + 2 + 1 + 8 + 20 + 1 + group_bytes;
    
    if (out_sz < total_size) {
        written = 0;
        return market::runtime::status::short_buffer;
    }
    
    size_t offset = 0;
    
    // StartOfMessage (u16 LE, fixed value 0xBABA)
    market::runtime::store_le<uint16_t>(out + offset, 0xBABA);
    offset += 2;
    
    // MessageLength (u16 LE, total message size)
    market::runtime::store_le<uint16_t>(out + offset, static_cast<uint16_t>(total_size));
    offset += 2;
    
    // MessageType (u8, NewOrderCross enum value)
    out[offset] = static_cast<uint8_t>(MessageType::NewOrderCross);
    offset += 1;
    
    // PresenceBits (u64 LE)
    market::runtime::store_le<uint64_t>(out + offset, m.PresenceBits);
    offset += 8;
    
    // CrossId (char[20])
    std::memcpy(out + offset, m.CrossId.data(), 20);
    offset += 20;
    
    // GroupCount (u8)
    out[offset] = static_cast<uint8_t>(m.groups.size());
    offset += 1;
    
    // Encode each group
    for (const auto& group : m.groups) {
        // Side (u8)
        out[offset] = group.Side;
        offset += 1;
        
        // AllocQty (u32 LE)
        market::runtime::store_le<uint32_t>(out + offset, group.AllocQty);
        offset += 4;
        
        // ClOrdId (char[20])
        std::memcpy(out + offset, group.ClOrdId.data(), 20);
        offset += 20;
        
        // Account (char[16]) - conditional based on presence bit 9
        if (include_account) {
            std::memcpy(out + offset, group.Account.data(), 16);
            offset += 16;
        }
    }
    
    written = total_size;
    return market::runtime::status::ok;
}

{%- endif %}

{%- if schema.get('messages', {}).get('AddOrder') %}

market::runtime::status Encoder::encode(const AddOrder& m, uint8_t* out, size_t out_sz, size_t& written) {
    constexpr size_t TOTAL_SIZE = 1 + 4 + 8 + 1 + 4 + 8 + 4; // Type + Timestamp + OrderId + Side + Shares + Symbol + Price
    
    if (out_sz < TOTAL_SIZE) {
        written = 0;
        return market::runtime::status::short_buffer;
    }
    
    size_t offset = 0;
    
    // Type (char, fixed value 'A')
    out[offset] = 'A';
    offset += 1;
    
    // Timestamp (u32 BE)
    market::runtime::store_be<uint32_t>(out + offset, m.Timestamp);
    offset += 4;
    
    // OrderId (u64 BE)
    market::runtime::store_be<uint64_t>(out + offset, m.OrderId);
    offset += 8;
    
    // Side (char)
    out[offset] = m.Side;
    offset += 1;
    
    // Shares (u32 BE)
    market::runtime::store_be<uint32_t>(out + offset, m.Shares);
    offset += 4;
    
    // Symbol (char[8])
    std::memcpy(out + offset, m.Symbol.data(), 8);
    offset += 8;
    
    // Price (u32 BE)
    market::runtime::store_be<uint32_t>(out + offset, m.Price);
    offset += 4;
    
    written = TOTAL_SIZE;
    return market::runtime::status::ok;
}

{%- endif %}

{%- if schema.get('messages', {}).get('DeleteOrder') %}

market::runtime::status Encoder::encode(const DeleteOrder& m, uint8_t* out, size_t out_sz, size_t& written) {
    constexpr size_t TOTAL_SIZE = 1 + 4 + 8; // Type + Timestamp + OrderId
    
    if (out_sz < TOTAL_SIZE) {
        written = 0;
        return market::runtime::status::short_buffer;
    }
    
    size_t offset = 0;
    
    // Type (char, fixed value 'D')
    out[offset] = 'D';
    offset += 1;
    
    // Timestamp (u32 BE)
    market::runtime::store_be<uint32_t>(out + offset, m.Timestamp);
    offset += 4;
    
    // OrderId (u64 BE)
    market::runtime::store_be<uint64_t>(out + offset, m.OrderId);
    offset += 8;
    
    written = TOTAL_SIZE;
    return market::runtime::status::ok;
}

{%- endif %}

{%- if ns_parts|length > 1 %}
}  // namespace v{{ version }}
}  // namespace {{ ns_parts[1] }}
}  // namespace {{ ns_parts[0] }}
{%- else %}
}  // namespace v{{ version }}
}  // namespace {{ protocol }}
{%- endif %}
