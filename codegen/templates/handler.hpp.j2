// *** AUTOGENERATED â€“ DO NOT EDIT (run: python codegen/generate.py) ***
#pragma once

#include "messages.hpp"
#include "decoder.hpp"
#include "runtime/bytes.hpp"
#include "runtime/status.hpp"
#include "runtime/endian.hpp"

{%- set ns_parts = protocol.split('_') %}
{%- if ns_parts|length > 1 %}

namespace {{ ns_parts[0] }} { 
namespace {{ ns_parts[1] }} { 
namespace v{{ version }} {

{%- else %}

namespace {{ protocol }} { 
namespace v{{ version }} {

{%- endif %}

{%- if schema.protocol == 'cboe_boe' %}

// BOE protocol dispatcher - validates preamble and dispatches by MessageType
template<class H>
inline market::runtime::status dispatch_boe(market::runtime::Bytes in, H& h, size_t& consumed) {
    using market::runtime::status;
    using market::runtime::load_le;
    
    // Validate minimum header size (StartOfMessage + MessageLength + MessageType)
    if (in.size() < 5) {
        return status::short_buffer;
    }
    
    // Validate StartOfMessage (0xBABA LE)
    uint16_t start_of_message = load_le<uint16_t>(in.data());
    if (start_of_message != 0xBABA) {
        return status::bad_value;
    }
    
    // Read MessageType at byte offset 4
    uint8_t message_type = in.data()[4];
    
    switch (message_type) {
{%- if 'LoginRequest' in schema.messages %}

        case static_cast<uint8_t>(MessageType::LoginRequest): {
            LoginRequest msg;
            auto decode_status = Decoder::decode(in.data(), in.size(), msg, consumed);
            if (decode_status != status::ok) {
                return decode_status;
            }
            h.on(msg);
            return status::ok;
        }
{%- endif %}
{%- if 'NewOrderCross' in schema.messages %}

        case static_cast<uint8_t>(MessageType::NewOrderCross): {
            NewOrderCross msg;
            auto decode_status = Decoder::decode(in.data(), in.size(), msg, consumed);
            if (decode_status != status::ok) {
                return decode_status;
            }
            h.on(msg);
            return status::ok;
        }
{%- endif %}

        default:
            return status::unknown_type;
    }
}

{%- elif schema.protocol == 'nasdaq_itch' %}

// ITCH protocol dispatcher - dispatches by Type field
template<class H>
inline market::runtime::status dispatch_itch(market::runtime::Bytes in, H& h, size_t& consumed) {
    using market::runtime::status;
    
    // Validate minimum size for Type field
    if (in.size() < 1) {
        return status::short_buffer;
    }
    
    // Read Type at byte 0
    char type = static_cast<char>(in.data()[0]);
    
    switch (type) {
{%- if 'AddOrder' in schema.messages %}

        case 'A': {
            AddOrder msg;
            auto decode_status = Decoder::decode(in.data(), in.size(), msg, consumed);
            if (decode_status != status::ok) {
                return decode_status;
            }
            h.on(msg);
            return status::ok;
        }
{%- endif %}
{%- if 'DeleteOrder' in schema.messages %}

        case 'D': {
            DeleteOrder msg;
            auto decode_status = Decoder::decode(in.data(), in.size(), msg, consumed);
            if (decode_status != status::ok) {
                return decode_status;
            }
            h.on(msg);
            return status::ok;
        }
{%- endif %}

        default:
            return status::unknown_type;
    }
}

{%- endif %}

{%- if ns_parts|length > 1 %}

}  // namespace v{{ version }}
}  // namespace {{ ns_parts[1] }}
}  // namespace {{ ns_parts[0] }}

{%- else %}

}  // namespace v{{ version }}
}  // namespace {{ protocol }}

{%- endif %}