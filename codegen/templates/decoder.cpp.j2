// *** AUTOGENERATED â€“ DO NOT EDIT (run: python codegen/generate.py) ***

#include "decoder.hpp"

{% set ns_parts = protocol.split('_') %}
{% if ns_parts|length > 1 %}

namespace {{ ns_parts[0] }} { namespace {{ ns_parts[1] }} { namespace v{{ version }} {

{% else %}

namespace {{ protocol }} { namespace v{{ version }} {

{% endif %}

{% for msg in model.messages %}
market::runtime::status Decoder::decode(const uint8_t* in, size_t in_sz, {{ msg.name }}& out, size_t& consumed) {
    using market::runtime::status;
    using market::runtime::load_le;
    using market::runtime::load_be;

    size_t offset = 0;

    // Parse fields
    {% for f in msg.fields %}
    {% if f.type == 'char' and f.size > 1 %}
    if (offset + {{ f.size }} > in_sz) { consumed = 0; return status::short_buffer; }
    std::memcpy(out.{{ f.name }}.data(), in + offset, {{ f.size }});
    offset += {{ f.size }};
    {% elif f.type == 'char' and f.size == 1 %}
    if (offset + 1 > in_sz) { consumed = 0; return status::short_buffer; }
    out.{{ f.name }} = static_cast<char>(in[offset]);
    offset += 1;
    {% elif f.type in ['u8','u16','u32','u64'] %}
    if (offset + {{ f.size }} > in_sz) { consumed = 0; return status::short_buffer; }
    {% if f.size == 1 %}
    out.{{ f.name }} = static_cast<uint8_t>(in[offset]);
    offset += 1;
    {% elif f.endian == 'le' %}
    out.{{ f.name }} = load_le<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(in + offset);
    offset += {{ f.size }};
    {% else %}
    out.{{ f.name }} = load_be<{{ 'uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t') }}>(in + offset);
    offset += {{ f.size }};
    {%- endif %}
    {% elif f.type == 'enum' %}
    {% set underlying = model.enums_map[f.enum_type].underlying %}
    if (offset + {{ model.enums_map[f.enum_type].width_bytes }} > in_sz) { consumed = 0; return status::short_buffer; }
    {% if model.enums_map[f.enum_type].width_bytes == 1 %}
    out.{{ f.name }} = static_cast<{{ f.enum_type }}>(in[offset]);
    offset += 1;
    {% elif f.endian == 'le' %}
    out.{{ f.name }} = static_cast<{{ f.enum_type }}>(load_le<{{ underlying }}>(in + offset));
    offset += {{ model.enums_map[f.enum_type].width_bytes }};
    {% else %}
    out.{{ f.name }} = static_cast<{{ f.enum_type }}>(load_be<{{ underlying }}>(in + offset));
    offset += {{ model.enums_map[f.enum_type].width_bytes }};
    {% endif %}
    {% else %}
    if (offset + {{ f.size }} > in_sz) { consumed = 0; return status::short_buffer; }
    std::memcpy(&out.{{ f.name }}, in + offset, {{ f.size }});
    offset += {{ f.size }};
    {% endif %}
    {# Value checks #}
    {% if f.has_value and f.type == 'char' and f.size == 1 %}
    if (out.{{ f.name }} != static_cast<char>({{ "'{}'".format(f.value) if f.value is string else f.value }})) { consumed = 0; return status::bad_value; }
    {% elif f.has_value and f.type in ['u8','u16','u32','u64'] %}
    if (out.{{ f.name }} != static_cast<{{ 'uint8_t' if f.size==1 else ('uint16_t' if f.size==2 else ('uint32_t' if f.size==4 else 'uint64_t')) }}>({{ f.value }})) { consumed = 0; return status::bad_value; }
    {% endif %}
    {% endfor %}

    // Special checks: MessageType equals message name (if present as enum)
    {% for f in msg.fields %}
    {% if f.type == 'enum' and f.enum_type == 'MessageType' and f.name == 'MessageType' %}
    if (out.MessageType != {{ f.enum_type }}::{{ msg.name }}) { consumed = 0; return status::unknown_type; }
    {% endif %}
    {% endfor %}

    // Decode groups
    {% for g in msg.groups %}
    size_t group_count = static_cast<size_t>(out.{{ g.count_field }});
    out.{{ g.vector_name }}.clear();
    out.{{ g.vector_name }}.reserve(group_count);
    for (size_t i = 0; i < group_count; ++i) {
        {{ msg.name }}{{ g.name }} grp{};
        {% for gf in g.fields %}
        {% if gf.optional_bit is not none %}
        if ((out.{{ msg.presence_field }} & (1ULL << {{ gf.optional_bit }})) != 0) {
        {% endif %}
            {% if gf.type == 'char' and gf.size > 1 %}
            if (offset + {{ gf.size }} > in_sz) { consumed = 0; return status::short_buffer; }
            std::memcpy(grp.{{ gf.name }}.data(), in + offset, {{ gf.size }});
            offset += {{ gf.size }};
            {% elif gf.type == 'char' and gf.size == 1 %}
            if (offset + 1 > in_sz) { consumed = 0; return status::short_buffer; }
            grp.{{ gf.name }} = static_cast<char>(in[offset]);
            offset += 1;
            {% elif gf.type in ['u8','u16','u32','u64'] %}
            if (offset + {{ gf.size }} > in_sz) { consumed = 0; return status::short_buffer; }
            {% if gf.size == 1 %}
            grp.{{ gf.name }} = static_cast<uint8_t>(in[offset]);
            offset += 1;
            {% elif gf.endian == 'le' %}
            grp.{{ gf.name }} = load_le<{{ 'uint16_t' if gf.size==2 else ('uint32_t' if gf.size==4 else 'uint64_t') }}>(in + offset);
            offset += {{ gf.size }};
            {% else %}
            grp.{{ gf.name }} = load_be<{{ 'uint16_t' if gf.size==2 else ('uint32_t' if gf.size==4 else 'uint64_t') }}>(in + offset);
            offset += {{ gf.size }};
            {% endif %}
            {% elif gf.type == 'enum' %}
            {% set underlying = model.enums_map[gf.enum_type].underlying %}
            if (offset + {{ model.enums_map[gf.enum_type].width_bytes }} > in_sz) { consumed = 0; return status::short_buffer; }
            {% if model.enums_map[gf.enum_type].width_bytes == 1 %}
            grp.{{ gf.name }} = static_cast<{{ gf.enum_type }}>(in[offset]);
            offset += 1;
            {% elif gf.endian == 'le' %}
            grp.{{ gf.name }} = static_cast<{{ gf.enum_type }}>(load_le<{{ underlying }}>(in + offset));
            offset += {{ model.enums_map[gf.enum_type].width_bytes }};
            {% else %}
            grp.{{ gf.name }} = static_cast<{{ gf.enum_type }}>(load_be<{{ underlying }}>(in + offset));
            offset += {{ model.enums_map[gf.enum_type].width_bytes }};
            {% endif %}
            {% else %}
            if (offset + {{ gf.size }} > in_sz) { consumed = 0; return status::short_buffer; }
            std::memcpy(&grp.{{ gf.name }}, in + offset, {{ gf.size }});
            offset += {{ gf.size }};
            {% endif %}
        {% if gf.optional_bit is not none %}
        } else {
            {% if gf.type == 'char' and gf.size > 1 %}
            std::memset(grp.{{ gf.name }}.data(), 0, {{ gf.size }});
            {% else %}
            std::memset(&grp.{{ gf.name }}, 0, {{ gf.size }});
            {% endif %}
        }
        {% endif %}
        {% endfor %}
        out.{{ g.vector_name }}.push_back(grp);
    }
    {% endfor %}

    // Validate length field if present
    {% if msg.length_field %}
    if (out.{{ msg.length_field }} != static_cast<decltype(out.{{ msg.length_field }})>(offset)) { consumed = 0; return status::bad_value; }
    {% endif %}

    consumed = offset;
    return status::ok;
}

{% endfor %}

{% if ns_parts|length > 1 %}
}  // namespace v{{ version }}
}  // namespace {{ ns_parts[1] }}
}  // namespace {{ ns_parts[0] }}
{% else %}
}  // namespace v{{ version }}
}  // namespace {{ protocol }}
{% endif %}
