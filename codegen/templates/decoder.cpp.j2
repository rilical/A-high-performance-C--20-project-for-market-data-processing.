// *** AUTOGENERATED â€“ DO NOT EDIT (run: python codegen/generate.py) ***

#include "decoder.hpp"

{%- set ns_parts = protocol.split('_') %}
{%- if ns_parts|length > 1 %}

namespace {{ ns_parts[0] }} { namespace {{ ns_parts[1] }} { namespace v{{ version }} {
{%- else %}

namespace {{ protocol }} { namespace v{{ version }} {
{%- endif %}

{%- if schema.get('messages', {}).get('LoginRequest') %}

market::runtime::status Decoder::decode(const uint8_t* in, size_t in_sz, LoginRequest& out, size_t& consumed) {
    constexpr size_t MIN_HEADER_SIZE = 2 + 2 + 1; // StartOfMessage + MessageLength + MessageType
    
    if (in_sz < MIN_HEADER_SIZE) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    
    size_t offset = 0;
    
    // StartOfMessage (u16 LE, must be 0xBABA)
    uint16_t start_of_message = market::runtime::load_le<uint16_t>(in + offset);
    if (start_of_message != 0xBABA) {
        consumed = 0;
        return market::runtime::status::bad_value;
    }
    offset += 2;
    
    // MessageLength (u16 LE)
    uint16_t message_length = market::runtime::load_le<uint16_t>(in + offset);
    offset += 2;
    
    // Check if we have enough data for the full message
    if (in_sz < message_length) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    
    // MessageType (u8, must be LoginRequest)
    uint8_t message_type = in[offset];
    if (message_type != static_cast<uint8_t>(MessageType::LoginRequest)) {
        consumed = 0;
        return market::runtime::status::unknown_type;
    }
    offset += 1;
    
    // Check expected message length for LoginRequest
    constexpr size_t EXPECTED_SIZE = 2 + 2 + 1 + 4 + 20;
    if (message_length != EXPECTED_SIZE) {
        consumed = 0;
        return market::runtime::status::bad_value;
    }
    
    // Username (char[4])
    if (offset + 4 > in_sz) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    std::memcpy(out.Username.data(), in + offset, 4);
    offset += 4;
    
    // Password (char[20])
    if (offset + 20 > in_sz) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    std::memcpy(out.Password.data(), in + offset, 20);
    offset += 20;
    
    // Fill in the fixed fields
    out.StartOfMessage = 0xBABA;
    out.MessageLength = message_length;
    out.MessageType = MessageType::LoginRequest;
    
    consumed = message_length;
    return market::runtime::status::ok;
}

{%- endif %}

{%- if ns_parts|length > 1 %}
}  // namespace v{{ version }}
}  // namespace {{ ns_parts[1] }}
}  // namespace {{ ns_parts[0] }}
{%- else %}
}  // namespace v{{ version }}
}  // namespace {{ protocol }}
{%- endif %}
