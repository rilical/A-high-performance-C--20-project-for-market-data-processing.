// *** AUTOGENERATED â€“ DO NOT EDIT (run: python codegen/generate.py) ***

#include "decoder.hpp"

{%- set ns_parts = protocol.split('_') %}
{%- if ns_parts|length > 1 %}

namespace {{ ns_parts[0] }} { namespace {{ ns_parts[1] }} { namespace v{{ version }} {
{%- else %}

namespace {{ protocol }} { namespace v{{ version }} {
{%- endif %}

{%- if schema.get('messages', {}).get('LoginRequest') %}

market::runtime::status Decoder::decode(const uint8_t* in, size_t in_sz, LoginRequest& out, size_t& consumed) {
    constexpr size_t MIN_HEADER_SIZE = 2 + 2 + 1; // StartOfMessage + MessageLength + MessageType
    
    if (in_sz < MIN_HEADER_SIZE) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    
    size_t offset = 0;
    
    // StartOfMessage (u16 LE, must be 0xBABA)
    uint16_t start_of_message = market::runtime::load_le<uint16_t>(in + offset);
    if (start_of_message != 0xBABA) {
        consumed = 0;
        return market::runtime::status::bad_value;
    }
    offset += 2;
    
    // MessageLength (u16 LE)
    uint16_t message_length = market::runtime::load_le<uint16_t>(in + offset);
    offset += 2;
    
    // Check if we have enough data for the full message
    if (in_sz < message_length) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    
    // MessageType (u8, must be LoginRequest)
    uint8_t message_type = in[offset];
    if (message_type != static_cast<uint8_t>(MessageType::LoginRequest)) {
        consumed = 0;
        return market::runtime::status::unknown_type;
    }
    offset += 1;
    
    // Check expected message length for LoginRequest
    constexpr size_t EXPECTED_SIZE = 2 + 2 + 1 + 4 + 20;
    if (message_length != EXPECTED_SIZE) {
        consumed = 0;
        return market::runtime::status::bad_value;
    }
    
    // Username (char[4])
    if (offset + 4 > in_sz) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    std::memcpy(out.Username.data(), in + offset, 4);
    offset += 4;
    
    // Password (char[20])
    if (offset + 20 > in_sz) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    std::memcpy(out.Password.data(), in + offset, 20);
    offset += 20;
    
    // Fill in the fixed fields
    out.StartOfMessage = 0xBABA;
    out.MessageLength = message_length;
    out.MessageType = MessageType::LoginRequest;
    
    consumed = message_length;
    return market::runtime::status::ok;
}

{%- endif %}

{%- if schema.get('messages', {}).get('NewOrderCross') %}

market::runtime::status Decoder::decode(const uint8_t* in, size_t in_sz, NewOrderCross& out, size_t& consumed) {
    constexpr size_t MIN_HEADER_SIZE = 2 + 2 + 1; // StartOfMessage + MessageLength + MessageType
    
    if (in_sz < MIN_HEADER_SIZE) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    
    size_t offset = 0;
    
    // StartOfMessage (u16 LE, must be 0xBABA)
    uint16_t start_of_message = market::runtime::load_le<uint16_t>(in + offset);
    if (start_of_message != 0xBABA) {
        consumed = 0;
        return market::runtime::status::bad_value;
    }
    offset += 2;
    
    // MessageLength (u16 LE)
    uint16_t message_length = market::runtime::load_le<uint16_t>(in + offset);
    offset += 2;
    
    // Check if we have enough data for the full message
    if (in_sz < message_length) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    
    // MessageType (u8, must be NewOrderCross)
    uint8_t message_type = in[offset];
    if (message_type != static_cast<uint8_t>(MessageType::NewOrderCross)) {
        consumed = 0;
        return market::runtime::status::unknown_type;
    }
    offset += 1;
    
    // PresenceBits (u64 LE)
    if (offset + 8 > in_sz) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    uint64_t presence_bits = market::runtime::load_le<uint64_t>(in + offset);
    offset += 8;
    
    // CrossId (char[20])
    if (offset + 20 > in_sz) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    std::memcpy(out.CrossId.data(), in + offset, 20);
    offset += 20;
    
    // GroupCount (u8)
    if (offset + 1 > in_sz) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    uint8_t group_count = in[offset];
    offset += 1;
    
    // Clear and reserve space for groups
    out.groups.clear();
    out.groups.reserve(group_count);
    
    // Parse each group
    for (uint8_t i = 0; i < group_count; ++i) {
        NewOrderCrossGroups group;
        
        // Side (u8)
        if (offset + 1 > in_sz) {
            consumed = 0;
            return market::runtime::status::short_buffer;
        }
        group.Side = in[offset];
        offset += 1;
        
        // AllocQty (u32 LE)
        if (offset + 4 > in_sz) {
            consumed = 0;
            return market::runtime::status::short_buffer;
        }
        group.AllocQty = market::runtime::load_le<uint32_t>(in + offset);
        offset += 4;
        
        // ClOrdId (char[20])
        if (offset + 20 > in_sz) {
            consumed = 0;
            return market::runtime::status::short_buffer;
        }
        std::memcpy(group.ClOrdId.data(), in + offset, 20);
        offset += 20;
        
        // Account (char[16]) - conditional based on presence bit 9
        if ((presence_bits & (1ULL << 9)) != 0) {
            if (offset + 16 > in_sz) {
                consumed = 0;
                return market::runtime::status::short_buffer;
            }
            std::memcpy(group.Account.data(), in + offset, 16);
            offset += 16;
        } else {
            // Clear Account field if not present
            std::memset(group.Account.data(), 0, 16);
        }
        
        out.groups.push_back(group);
    }
    
    // Fill in the parsed fields
    out.PresenceBits = presence_bits;
    out.GroupCount = group_count;
    
    consumed = message_length;
    return market::runtime::status::ok;
}

{%- endif %}

{%- if schema.get('messages', {}).get('AddOrder') %}

market::runtime::status Decoder::decode(const uint8_t* in, size_t in_sz, AddOrder& out, size_t& consumed) {
    constexpr size_t TOTAL_SIZE = 1 + 4 + 8 + 1 + 4 + 8 + 4; // Type + Timestamp + OrderId + Side + Shares + Symbol + Price
    
    if (in_sz < TOTAL_SIZE) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    
    size_t offset = 0;
    
    // Type (char, must be 'A')
    char message_type = static_cast<char>(in[offset]);
    if (message_type != 'A') {
        consumed = 0;
        return market::runtime::status::bad_value;
    }
    out.Type = message_type;
    offset += 1;
    
    // Timestamp (u32 BE)
    out.Timestamp = market::runtime::load_be<uint32_t>(in + offset);
    offset += 4;
    
    // OrderId (u64 BE)
    out.OrderId = market::runtime::load_be<uint64_t>(in + offset);
    offset += 8;
    
    // Side (char)
    out.Side = static_cast<char>(in[offset]);
    offset += 1;
    
    // Shares (u32 BE)
    out.Shares = market::runtime::load_be<uint32_t>(in + offset);
    offset += 4;
    
    // Symbol (char[8])
    std::memcpy(out.Symbol.data(), in + offset, 8);
    offset += 8;
    
    // Price (u32 BE)
    out.Price = market::runtime::load_be<uint32_t>(in + offset);
    offset += 4;
    
    consumed = TOTAL_SIZE;
    return market::runtime::status::ok;
}

{%- endif %}

{%- if schema.get('messages', {}).get('DeleteOrder') %}

market::runtime::status Decoder::decode(const uint8_t* in, size_t in_sz, DeleteOrder& out, size_t& consumed) {
    constexpr size_t TOTAL_SIZE = 1 + 4 + 8; // Type + Timestamp + OrderId
    
    if (in_sz < TOTAL_SIZE) {
        consumed = 0;
        return market::runtime::status::short_buffer;
    }
    
    size_t offset = 0;
    
    // Type (char, must be 'D')
    char message_type = static_cast<char>(in[offset]);
    if (message_type != 'D') {
        consumed = 0;
        return market::runtime::status::bad_value;
    }
    out.Type = message_type;
    offset += 1;
    
    // Timestamp (u32 BE)
    out.Timestamp = market::runtime::load_be<uint32_t>(in + offset);
    offset += 4;
    
    // OrderId (u64 BE)
    out.OrderId = market::runtime::load_be<uint64_t>(in + offset);
    offset += 8;
    
    consumed = TOTAL_SIZE;
    return market::runtime::status::ok;
}

{%- endif %}

{%- if ns_parts|length > 1 %}
}  // namespace v{{ version }}
}  // namespace {{ ns_parts[1] }}
}  // namespace {{ ns_parts[0] }}
{%- else %}
}  // namespace v{{ version }}
}  // namespace {{ protocol }}
{%- endif %}
